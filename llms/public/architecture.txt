This architecture organizes an Angular 19+ workspace around strict isolation, a one‑way dependency graph, and explicit template contexts provided by standalone components. Features are always lazy and treated as black boxes: they expose UI through routes (or “drop‑in” pattern components) but never leak implementation. Shared logic follows the “extract one level up” rule into core, ui, or pattern, preserving independence and preventing cycles. Injector hierarchy is used deliberately: singletons are provided in the eager root; feature‑scoped providers live on each lazy EnvironmentInjector; element‑level providers are reserved for special cases.

The stack relies on the standalone APIs (`provideRouter`, `provideHttpClient`, functional guards/interceptors) and esbuild builders for fast feedback. Lazy routing (`loadChildren`) and `@defer` split bundles where it matters; UI standalones are “cherry‑picked,” keeping eager bundles small. Automated validation with `eslint-plugin-boundaries` encodes the architecture so dependency mistakes fail CI, removing “hope‑based architecture.” Esbuild provides significantly faster builds and enables even sizable apps to remain on a standard Angular CLI workspace.

──────────────────────────────────────────────────────────────────────────────
Workspace & folder tree (with purposes)

Note: The same rules apply whether the workspace uses /projects or /apps + /libs. This plan uses /apps and /libs as requested.

/apps ........................................ root for runnable applications (browser, admin, etc.).
  /my-app .................................... primary Angular SPA.
    /src
      /app ................................... application code organized by architecture types (core, layout, ui, pattern, feature).
        /core ................................ application-wide singletons, DI setup, domain services, state, and initialization logic.
          /auth .............................. domain folder: auth state/services, tokens, functional guards.
            auth.service.ts
            auth.guard.ts .................... functional guard; inject AuthService, Router.
            auth.tokens.ts
            index.ts
          /user .............................. domain: user profile clients, selectors, mappers.
          /http .............................. cross-cutting HTTP interceptors/options. Functional interceptors via provideHttpClient.
            logging.interceptor.ts
            auth.interceptor.ts
          /utils ............................. pure functions (dates, query params, parsing).
          core.ts ............................ provideCore({ routes }) — central app providers.
          index.ts
        /layout .............................. eager shell(s) that frame routed features; consumes core services & ui standalones.
          /main
            main-layout.component.ts
            main-layout.component.html
            index.ts
          /auth
            auth-layout.component.ts
            auth-layout.component.html
            index.ts
        /ui .................................. generic, state‑free standalones (components/directives/pipes) using only @Input/@Output; no services.
          /avatar
            avatar.component.ts
            index.ts
          /button
            button.component.ts
          /table
            data-table.component.ts
          /form
            form-field.component.ts
        /pattern ............................. “drop‑in” reusable patterns: packaged standalones + injectables, consumed by features/layouts.
          /document-manager
            document-manager.component.ts .... main drop‑in entry; heavy parts can be deferred in template.
            document.service.ts
            index.ts
          /approval-process
            approval.component.ts
            approval.service.ts
          /change-history
            change-history.component.ts
            change-history.service.ts
          /notes
            notes.component.ts
            notes.service.ts
        /feature ............................. lazy‑loaded business capabilities, fully isolated; may contain nested lazy sub‑features.
          /home .............................. example initial feature — still lazy to keep a single mental model.
            home.routes.ts ................... export default Routes with component + children.
            home.component.ts
            index.ts
          /orders ............................ domain feature (lazy).
            orders.routes.ts ................. route config; providers:[] for feature-scoped services.
            /data ............................ feature-scoped services, repositories, adapters (provided via routes).
              order.api.ts
              order.service.ts
              tokens.ts
              index.ts
            /ui .............................. feature-local standalones (not generic enough for /ui). Extract to /ui after 3+ usages.
              order-list.component.ts
              order-details.component.ts
            /sub-feature ..................... nested lazy sub-features for second-level navigation.
              /details
                details.routes.ts
                details.component.ts
            index.ts
          /customers
            customers.routes.ts
            /data
            /ui
            /sub-feature
          /shared-detail ..................... shared lazy feature (reused via route config, not direct TS imports).
            detail.routes.ts
            detail.component.ts
        app.component.ts ..................... either <router-outlet> or <my-org-main-layout>.
        app.routes.ts ........................ top-level routes using layouts & lazy features.
        app.config.ts ........................ provideCore({ routes }) + provideHttpClient(...).
      /assets ................................ static assets.
      /environments .......................... env files for build-time replacements.
    /e2e ..................................... end‑to‑end tests for this app (Playwright/Cypress).

/libs ........................................ organization libraries when the workspace grows; consumed via public APIs.
  /data-access ............................... shareable backend SDKs or adapters, exported via public-api.ts.
    /public-api.ts
    /src/lib/...
  /ui ........................................ cross‑app generic UI library if needed (mirror /apps/*/ui rules).
  /pattern ................................... cross‑app patterns; consumed by features/layouts.

/tools ....................................... tooling scripts & configs (madge graph, budgets, schematics, ESLint config helpers).
  /madge
    madge.config.mjs ........................ settings to visualize dependency graphs.
  /schematics
    README.md ................................ notes for ng-morph/schematics to generate features, guards, routes.
  /.eslintrc.js .............................. central ESLint + boundaries config (see below).

/e2e ......................................... optional global E2E project when testing multiple apps.

/.eslintignore
/.eslintrc.js ................................ alternative location for ESLint config.
/tsconfig.json
/angular.json ............................... use esbuild builders and budgets.
/package.json

Routing & lazy loading examples

Top-level routes with two layouts and lazy features:

/apps/my-app/src/app/app.routes.ts
----------------------------------------------------------------
export const routes: Routes = [
  {
    path: '',
    component: AuthLayoutComponent,
    children: [
      { path: 'login', loadChildren: () => import('./feature/home/home.routes') },
      // signup, recovery...
    ],
  },
  {
    path: 'app',
    component: MainLayoutComponent,
    children: [
      { path: 'orders', loadChildren: () => import('./feature/orders/orders.routes') },
      { path: 'customers', loadChildren: () => import('./feature/customers/customers.routes') },
    ],
  },
  { path: '', pathMatch: 'full', redirectTo: 'app/orders' },
  { path: '**', redirectTo: '' },
];

Feature route with feature‑scoped providers (isolation):

/apps/my-app/src/app/feature/orders/orders.routes.ts
----------------------------------------------------------------
import { Routes } from '@angular/router';
import { provideOrders } from './orders.providers';

export default [
  {
    path: '',
    providers: [provideOrders()],
    loadComponent: () => import('./ui/order-list.component').then(m => m.OrderListComponent),
    children: [
      { path: ':id', loadChildren: () => import('../shared-detail/detail.routes') },
    ],
  },
] as Routes;

@defer for heavy widgets inside a feature:

apps/my-app/src/app/feature/orders/ui/order-details.component.html
----------------------------------------------------------------
@defer (on viewport) {
  <my-org-chart [series]="series"></my-org-chart>
} @placeholder {
  <my-org-skeleton-chart></my-org-skeleton-chart>
}

Application bootstrap & providers

Centralized core provider:

apps/my-app/src/app/core/core.ts
----------------------------------------------------------------
import { Routes, provideRouter, withComponentInputBinding, withEnabledBlockingInitialNavigation, withInMemoryScrolling, withRouterConfig } from '@angular/router';
import { ENVIRONMENT_INITIALIZER, importProvidersFrom } from '@angular/core';
import { provideAnimationsAsync } from '@angular/platform-browser/animations/async';
import { provideHttpClient, withInterceptors } from '@angular/common/http';
import { authInterceptor } from './auth/auth.interceptor';

export interface CoreOptions { routes: Routes; }

export function provideCore({ routes }: CoreOptions) {
  return [
    provideAnimationsAsync(),
    provideRouter(
      routes,
      withRouterConfig({ onSameUrlNavigation: 'reload' }),
      withComponentInputBinding(),
      withEnabledBlockingInitialNavigation(),
      withInMemoryScrolling({ anchorScrolling: 'enabled', scrollPositionRestoration: 'enabled' }),
    ),
    provideHttpClient(withInterceptors([authInterceptor])),
    importProvidersFrom(/* third‑party NgModules if unavoidable */),
    {
      provide: ENVIRONMENT_INITIALIZER,
      multi: true,
      useValue() {
        // kick-start processes, app metrics, warm-ups…
      },
    },
  ];
}

Bootstrapping:

apps/my-app/src/app/app.config.ts
----------------------------------------------------------------
import { ApplicationConfig } from '@angular/core';
import { routes } from './app.routes';
import { provideCore } from './core/core';

export const appConfig: ApplicationConfig = {
  providers: [provideCore({ routes })],
};

Testing conventions

• Unit tests: colocate *.spec.ts next to implementation in each folder. Feature tests cover only that feature; changes in one feature must not break others.
• E2E: per‑app E2E in /apps/my-app/e2e or a central /e2e when scenarios span multiple apps. Prefer deep links for nested routes.

Heuristics & rules of thumb

• Every feature is lazy; even the first one.
• If feature A needs logic from feature B, extract one level up to core (injectables/state), ui (generic standalones), or pattern (configurable drop‑in). Never import a sibling feature.
• UI in /ui is standalone‑only (no services). If a component needs data, the parent feature provides it via inputs/outputs; if coupling grows, convert to a pattern.
• Prefer function‑based guards/interceptors/services using inject(); reserve element providers for rare per‑component instances.
• Prioritize isolation over DRY. Wait for at least 3 real repetitions before extracting.
• Use esbuild builders; analyze bundles with budgets and visualize imports with madge to ensure a clean one‑way dependency flow.

ESLint — eslint-plugin-boundaries config stub
(Place in /.eslintrc.js or /tools/.eslintrc.js)

```js
// .eslintrc.js  — boundaries config stub for /apps + /libs layout
/** @type {import('eslint').Linter.Config} */
module.exports = {
  overrides: [
    {
      files: ['*.ts'],
      plugins: ['boundaries'],
      extends: [
        // ...your standard Angular/TS presets,
        'plugin:boundaries/strict', // all files must belong to a known type
      ],
      settings: {
        'import/resolver': { typescript: { alwaysTryTypes: true } },
        'boundaries/dependency-nodes': ['import', 'dynamic-import'],
        'boundaries/ignore': [
          '**/jest*.ts',
          '**/*.spec.ts',
          '**/e2e/**',
        ],
        'boundaries/elements': [
          { type: 'main', mode: 'file', pattern: 'main.ts', basePattern: 'apps/**/src', baseCapture: ['app'] },
          { type: 'app',  mode: 'file', pattern: 'app(.*).ts', basePattern: 'apps/**/src/app', baseCapture: ['app'] },

          { type: 'core',    pattern: 'core',    basePattern: 'apps/**/src/app', baseCapture: ['app'] },
          { type: 'ui',      pattern: 'ui',      basePattern: 'apps/**/src/app', baseCapture: ['app'] },
          { type: 'layout',  pattern: 'layout',  basePattern: 'apps/**/src/app', baseCapture: ['app'] },
          { type: 'pattern', pattern: 'pattern', basePattern: 'apps/**/src/app', baseCapture: ['app'] },

          { type: 'feature-routes', mode: 'file', pattern: 'feature/*/*.routes.ts', capture: ['feature'], basePattern: 'apps/**/src/app', baseCapture: ['app'] },
          { type: 'feature',        pattern: 'feature/*',       capture: ['feature'], basePattern: 'apps/**/src/app', baseCapture: ['app'] },

          { type: 'lib-api', mode: 'file', pattern: 'libs/*/public-api.ts', capture: ['lib'] },
          { type: 'lib',     pattern: 'libs/*/src/lib',         capture: ['lib'] },
        ],
      },
      rules: {
        'boundaries/element-types': ['error', {
          default: 'disallow',
          rules: [
            { from: 'main', allow: [['app', { app: '${from.app}' }]] },

            { from: 'core',   allow: [['core', { app: '${from.app}' }], ['lib-api']] },
            { from: 'ui',     allow: [['ui',   { app: '${from.app}' }], ['lib-api']] },
            { from: 'layout', allow: [
              ['core', { app: '${from.app}' }],
              ['ui',   { app: '${from.app}' }],
              ['pattern', { app: '${from.app}' }],
              ['lib-api'],
            ]},
            { from: 'app', allow: [
              ['app', { app: '${from.app}' }],
              ['core', { app: '${from.app}' }],
              ['layout', { app: '${from.app}' }],
              ['feature-routes', { app: '${from.app}' }],
              ['lib-api'],
            ]},
            { from: 'pattern', allow: [
              ['core', { app: '${from.app}' }],
              ['ui',   { app: '${from.app}' }],
              ['pattern', { app: '${from.app}' }],
              ['lib-api'],
            ]},
            { from: 'feature', allow: [
              ['core', { app: '${from.app}' }],
              ['ui',   { app: '${from.app}' }],
              ['pattern', { app: '${from.app}' }],
              ['lib-api'],
            ]},
            { from: 'feature-routes', allow: [
              ['core', { app: '${from.app}' }],
              ['pattern', { app: '${from.app}' }],
              ['feature', { app: '${from.app}', feature: '${from.feature}' }],
              ['feature-routes', { app: '${from.app}', feature: '!${from.feature}' }],
              ['lib-api'],
            ]},

            { from: 'lib-api', allow: [['lib', { lib: '${from.lib}' }]] },
            { from: 'lib',     allow: [['lib', { lib: '${from.lib}' }]] },
          ],
        }],
      },
    },
  ],
};
```
