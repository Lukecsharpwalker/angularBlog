# app-llm.txt — Copilot / LLM brief for angular.fun (Angular 20+)

## Goal
Rebuild **angular.fun** as a clean Angular 20+ multi‑project workspace (no Nx) with three independently deployed apps and shared libraries:

- **blog-ssg** (public): Hybrid rendering (**SSG for articles**, **SSR for home**; CSR where needed). Deployed to **Google Cloud Run** from source using buildpacks. SEO and Core Web Vitals are top priority. [docs: hybrid rendering, route‑level render mode, Cloud Run deploy from source]
- **admin-spa**: Pure CSR admin panel. Deployed to **Firebase Hosting**.
- **code-samples-mfe**: Micro‑frontend for heavy examples, loaded lazily from the blog via **Native Federation** (Angular Architects). Deployed to **Firebase Hosting**.
- **libs/shared**: UI (presentational), pattern (composable UI + injectables), data‑access (REST clients, mappers, Supabase helpers).

**State**: Signals for local state; **NgRx SignalStore** for shared/domain state and collections.

**Data**: Supabase (Postgres + Auth + Storage). Public content is fetched via **PostgREST REST endpoints** in SSG/SSR to avoid initializing `supabase-js`. Admin/MFE can use `@supabase/supabase-js`. Public assets come from **Supabase Storage CDN**.

**A11y & Performance**: Aim for **100/100/100/100 Lighthouse** on the home page. Enforce with Lighthouse CI in GitHub Actions. Add Playwright + axe accessibility checks.

---

## Projects & folders

**Workspace (Angular CLI):**
- `apps/blog-ssg` — public reader app
- `apps/admin-spa` — admin
- `apps/code-samples-mfe` — remote
- `libs/shared/ui` — presentational, stateless standalone components
- `libs/shared/pattern` — reusable building blocks (standalone + service)
- `libs/shared/data-access` — REST clients, DTOs, adapters, Supabase REST helper

**Inside each app:**
- `core/` — `provideCore({ routes })`, Http interceptors, error handling, analytics
- `layout/` — top‑level shells and frames
- `ui/` — purely presentational standalone components
- `pattern/` — configurable composites (can inject services, but keep DI stable)
- `feature/` — **always lazy** features per route
- Enforce one‑way dependency flow with **eslint-plugin-boundaries**.

Rule of three: if a piece of functionality repeats ≥3 times, extract to `ui`, `pattern` or `data-access`.

---

## Rendering model

### blog-ssg (public)
- **Routes**
  - `/` → **SSR** (freshness, future personalization)
  - `/posts/:slug` → **SSG** (prerendered)
  - others → choose CSR/SSR case‑by‑case via **route‑level render mode**.
- **Hydration**
  - Enable hydration by default.
  - For incompatible widgets, wrap with a component using `host: { ngSkipHydration: 'true' }`.
- **Deferrable views**
  - Wrap heavy, non‑critical UI in `@defer` with placeholders and `on viewport/idle` triggers.
- **Images**
  - Use `NgOptimizedImage`. LCP image must be priority. Use Supabase Storage public URLs as the origin; consider a thin loader function for width/format parameters if using the image resizing gateway.

### admin-spa
- CSR only. Quill/editor packages lazy‑loaded here. No SSR/SSG or SEO work required.

### code-samples-mfe
- Use **Native Federation**. Expose a routes module. Loaded lazily from blog with `loadRemoteModule('samples', './routes')`. Share Angular/RxJS as singletons. No SSR/SSG.

---

## Data access

- **Public read (blog-ssg)**: call **PostgREST** endpoints with the anon key and RLS‑safe policies. Prefer server‑side requests during prerender/SSR to avoid leaking keys to clients. For SSG, the build script generates `routes.txt` by fetching `id`/`slug` of published posts.
- **Admin/MFE**: use `@supabase/supabase-js` browser client.
- **Auth**: already implemented with Supabase. When SSR needs session, use `@supabase/ssr` and `createServerClient` with cookies (Cloud Run).
- **Storage**: serve images from Supabase **CDN** (public bucket). Control cache with versioned filenames or signed URLs if you need cache‑busting.

---

## State management (strict)

- Local component state: `signal`, `computed`, `linkedSignal`.
- Shared/domain state: **NgRx SignalStore** (`@ngrx/signals`):
  - Structure with `withState`, `withComputed`, `withMethods`, `withHooks`.
  - Immutable updates via **`patchState`** (no mutations).
  - Collections: `withEntities` + updaters (`addEntities`, `setEntities`, `updateEntity`, `removeEntity`, …).
  - RxJS interop: `rxMethod` for effectful pipelines; use Angular `toSignal`/`toObservable` where needed.

---

## Tooling & versions

- **Angular 20+**.
- **Node.js LTS**: **20.19+** (Angular 20 drops Node 18). Configure Actions runners to Node 20.
- **Package manager**: `pnpm` recommended (fast, content‑addressable store). Use `actions/setup-node` caching with `cache: 'pnpm'`.

---

## CI/CD

### Overview
- Separate jobs for each app. Common `test` job first.
- **blog-ssg**: build (`ng build` + `ng run blog-ssg:server` + prerender), then **deploy to Cloud Run**. Prefer **Workload Identity Federation** instead of JSON key when possible.
- **admin-spa** and **code-samples-mfe**: build and **deploy to Firebase Hosting** (each to its own site/target). Use `firebase init hosting:github` to scaffold.
- **Lighthouse CI**: run on the preview/live URL of the **home page** only. Thresholds set to 1.00 for all categories; fail PRs on regressions.
- **Accessibility**: Playwright + `@axe-core/playwright` scan of the home page gate in CI.

### Monorepo workflow (sketch)
See `.github/workflows/ci.yml` below for a consolidated workflow.

---

## Example snippets

### 1) Route-level render mode (blog-ssg)
```ts
import type { ServerRoute } from '@angular/ssr';

export const serverRoutes: ServerRoute[] = [
  { path: '', renderMode: 'ssr' },            // home
  { path: 'posts/:slug', renderMode: 'ssg' }, // articles
  { path: 'search', renderMode: 'csr' },      // client-only
];
```

### 2) Native Federation lazy route (blog → samples)
```ts
import { Routes } from '@angular/router';
import { loadRemoteModule } from '@angular-architects/native-federation';

export const routes: Routes = [
  {
    path: 'examples',
    loadChildren: () => loadRemoteModule('samples', './routes').then(m => m.routes),
  },
];
```

### 3) SignalStore skeleton
```ts
import { signalStore, withState, withComputed, withMethods, withHooks, patchState } from '@ngrx/signals';
import { computed, inject } from '@angular/core';
import { HttpClient } from '@angular/common/http';

interface Post { id: string; slug: string; title: string; html: string; }
interface State { loading: boolean; error: string | null; items: Post[]; selectedId: string | null; }
const initial: State = { loading: false, error: null, items: [], selectedId: null };

export const PostsStore = signalStore(
  { providedIn: 'root' },
  withState(initial),
  withComputed(({ items, selectedId }) => ({
    count: computed(() => items().length),
    selected: computed(() => items().find(p => p.id === selectedId())),
  })),
  withMethods((store, http = inject(HttpClient)) => ({
    async loadAll() {
      patchState(store, { loading: true, error: null });
      try {
        const data = await http.get<Post[]>('/api/posts').toPromise();
        patchState(store, { items: data ?? [], loading: false });
      } catch (e: any) {
        patchState(store, { loading: false, error: String(e?.message ?? e) });
      }
    },
    select(id: string | null) { patchState(store, { selectedId: id }); },
  })),
  withHooks({ onInit() {/* optional prefetch */} }),
);
```

### 4) `routes.txt` generator (Node script using PostgREST)
```ts
// scripts/generate-routes.ts
// Usage: node scripts/generate-routes.mjs > apps/blog-ssg/routes.txt
import fs from 'node:fs/promises';
import process from 'node:process';

const REST_URL = process.env.SUPABASE_REST_URL; // https://<ref>.supabase.co/rest/v1
const ANON_KEY = process.env.SUPABASE_ANON_KEY;
if (!REST_URL || !ANON_KEY) {
  console.error('Missing SUPABASE_REST_URL or SUPABASE_ANON_KEY'); process.exit(1);
}

const headers = {
  apikey: ANON_KEY,
  Authorization: `Bearer ${ANON_KEY}`,
  Prefer: 'count=exact',
};

// Query only published posts and select slug
const url = new URL('/rest/v1/posts', REST_URL);
url.searchParams.set('select', 'slug');
url.searchParams.set('published', 'eq.true');
url.searchParams.set('order', 'id.asc');
url.searchParams.set('limit', '10000');

const res = await fetch(url, { headers });
if (!res.ok) {
  console.error('PostgREST error', res.status, await res.text()); process.exit(1);
}
const rows = await res.json();
const routes = ['/', ...rows.map((r) => `/posts/${r.slug}`)];
await fs.writeFile('apps/blog-ssg/routes.txt', routes.join('\n'), 'utf8');
console.log(`Generated ${routes.length} routes.`);
```

### 5) Playwright + axe accessibility test (home page)
```ts
// e2e/a11y.spec.ts
import { test, expect } from '@playwright/test';
import { AxeBuilder } from '@axe-core/playwright';

test('home has no critical a11y violations', async ({ page }) => {
  await page.goto(process.env.E2E_BASE_URL ?? 'https://angular.fun/');
  const accessibilityScanResults = await new AxeBuilder({ page })
    .withTags(['wcag2a', 'wcag2aa'])
    .analyze();
  expect(accessibilityScanResults.violations).toEqual([]);
});
```

### 6) GitHub Actions (monorepo, Node 20, pnpm, Cloud Run + Firebase + LHCI)
```yaml
name: CI

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

env:
  NODE_VERSION: '20.19.0' # Angular 20 requires Node >= 20.19.x
  PROJECT_ID: your-gcp-project
  REGION: europe-west4
  CLOUD_RUN_SERVICE: angular-blog
  BLOG_URL: https://angular.fun/

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'pnpm'
      - uses: pnpm/action-setup@v4
        with: { run_install: false }
      - run: corepack enable
      - run: pnpm install --frozen-lockfile
      - run: pnpm run lint
      - run: pnpm run test -- --watch=false --browsers=ChromeHeadless

  blog:
    needs: test
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'pnpm'
      - uses: pnpm/action-setup@v4
        with: { run_install: false }
      - run: corepack enable
      - run: pnpm install --frozen-lockfile
      - name: Generate prerender routes
        run: node scripts/generate-routes.mjs
        env:
          SUPABASE_REST_URL: ${{ secrets.SUPABASE_REST_URL }}
          SUPABASE_ANON_KEY: ${{ secrets.SUPABASE_ANON_KEY }}
      - name: Build blog (browser + server + prerender)
        run: |
          pnpm ng build blog-ssg --configuration=production
          pnpm ng run blog-ssg:server:production
          pnpm ng run blog-ssg:prerender --routes=apps/blog-ssg/routes.txt
      - uses: google-github-actions/auth@v2
        with:
          # Recommend switching to Workload Identity Federation later
          credentials_json: ${{ secrets.GCP_SA_KEY }}
      - name: Deploy to Cloud Run (buildpacks from source)
        uses: google-github-actions/deploy-cloudrun@v2
        with:
          service: ${{ env.CLOUD_RUN_SERVICE }}
          region: ${{ env.REGION }}
          source: .
          # Optionally pass environment variables to the container if using start script
      - name: Lighthouse CI
        run: |
          pnpm dlx @lhci/cli autorun                 --collect.url=${{ env.BLOG_URL }}                 --assert.assertions.categories:performance=">=1"                 --assert.assertions.categories:accessibility=">=1"                 --assert.assertions.categories:best-practices=">=1"                 --assert.assertions.categories:seo=">=1"

  admin:
    needs: test
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'pnpm'
      - uses: pnpm/action-setup@v4
        with: { run_install: false }
      - run: corepack enable
      - run: pnpm install --frozen-lockfile
      - run: pnpm ng build admin-spa --configuration=production
      - name: Deploy to Firebase Hosting (admin)
        uses: FirebaseExtended/action-hosting-deploy@v0
        with:
          repoToken: ${{ secrets.GITHUB_TOKEN }}
          firebaseServiceAccount: ${{ secrets.FIREBASE_SERVICE_ACCOUNT }}
          channelId: live
          projectId: your-firebase-project
          target: admin

  samples:
    needs: test
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'pnpm'
      - uses: pnpm/action-setup@v4
        with: { run_install: false }
      - run: corepack enable
      - run: pnpm install --frozen-lockfile
      - run: pnpm ng build code-samples-mfe --configuration=production
      - name: Deploy to Firebase Hosting (samples)
        uses: FirebaseExtended/action-hosting-deploy@v0
        with:
          repoToken: ${{ secrets.GITHUB_TOKEN }}
          firebaseServiceAccount: ${{ secrets.FIREBASE_SERVICE_ACCOUNT }}
          channelId: live
          projectId: your-firebase-project
          target: samples
```

> **Note**: Cloud Run deploys from source using buildpacks. Ensure `package.json` has a `start` script that launches the SSR server (e.g. `node dist/apps/blog-ssg/server/server.mjs`). Alternatively, switch to a **Dockerfile** with an explicit build and run command if you need more control.

---

## i18n roadmap

- Start English‑only. Next locale: **pl**.
- Use Angular i18n (`@angular/localize`) and extraction. Configure localized builds and route prefixes (`/en/...`, `/pl/...`). The dev server can run **one locale at a time**; use `ng serve --configuration=pl` when needed.
- For SSG, generate routes per locale (e.g. `apps/blog-ssg/routes.en.txt`, `routes.pl.txt`) and run prerender for both. Route‑level render mode still applies per locale.

---

## SEO decisions

- Generate server‑side meta (title, description, canonical, Open Graph, Twitter). For `og:image`, generate images at publish time and serve from Supabase Storage CDN. Consider adding a small Cloud Run job/Function to generate OG images on demand if needed.

---

## Styling
- **Tailwind + DaisyUI**. Provide design tokens (colors, spacing, font scale). Set CSS budget limits in `angular.json`. Monitor CSS size in CI.

